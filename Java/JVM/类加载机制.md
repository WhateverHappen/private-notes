类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)** 7个阶段。其中，验证、准备、解析3个部分统称为连接(Linking)，如图：

![1526136098425](1526136098425.png)

其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而**解析阶段为了支持Java的运行时绑定，在某些情况下可以在初始化阶段之后再开始**。

## 加载

加载时类加载过程中的一个阶段，这个阶段会在堆中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取(比如从jar包和war包中读取)，也可以在运行时计算生成(动态代理)，也可以由其他文件生成(比如将JSP文件转换成对应的Class类)

## 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证

1. 文件格式验证

   第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理

2. 元数据验证

   第二阶段是对字节码描述的信息进行语义分析，以确保其描述的信息符合Java语言规范的要求。

3. 字节码验证

   该阶段的主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。

4. 符号引用验证

   最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。**首先，这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值通常情况下是数据类型的零值，**假设一个类变量的定义为：

`public static int value = 123;`

那变量value在准备阶段过后的初始值为0，而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的普通static指令是程序被编译后，存放于类构造器\<clinit\>()方法之中，所以**把value赋值为123的动作将在初始化阶段才会执行**。

> 如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：
>
> `public static final int value = 123;`
>
> 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123.

## 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

+ 符号引用

  符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的布局可以各不相同，但是他们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

+ 直接引用

  直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。

## 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。

以下几种情况不会执行类初始化：

- 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化
- 定义对象数组，不会触发该类的初始化
- 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类
- 通过类名获取Class对象，不会触发类的初始化
- 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化
- 通过ClassLoader默认的loadClass方法，也不会触发初始化动作
