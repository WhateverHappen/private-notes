# 主内存和工作内存

**Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和内存中取出变量这样的底层细节**。此处的变量与Java编程中的变量有所不同，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。

JMM规定了所有的变量都存储在主内存(Main Memory)中。每个线程还有自己的工作内存(Working Memory)，线程的**工作内存中保存了该线程使用到的变量的主内存的副本拷贝**，**线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量**(volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般)。**不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成**。

![img](./091134177063947.jpg)

这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。

# 原子性、可见性与有序性

Java内存模型是围绕着并发编程中**原子性、可见性、有序性**这三个特征来建立的

## 原子性

一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于实务操作，要么全部执行成功，要么回退到执行该操作之前的状态。

## 可见性

一个线程对共享变量做了修改之后，其他的线程立即能够看到该变量这种修改。

Java内存模型是通过**将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中**这种依赖主内存的方式来实现可见性的。无论是普通变量还是volatile变量都是如此，区别在于：**volatile的特殊规则保证了volatile变量值修改后的新值立即同步到主内存，每次使用volatile变量前立即从主内存中刷新**。因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。

除了cola提了关键字能实现可见性之外，还有synchronized，Lock，final也可以

使用synchronized关键字，在同步方法\同步块开始时，使用共享变量时会从主内存中刷新变量值到工作内存中，在同步块结束时，会将工作内存中的变量值同步到主内存中。

使用Lock接口的最常用的实现ReentrantLock来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized有相同的原理，即使用共享变量时会从主内存中刷新变量值到工作内存中，在方法的最后finally块里执行lock.unlock()方法，会将工作内存中的变量值同步到主内存中去

final关键字的可见性：被final修饰的变量，构造函数一旦初始化完成，并且在狗赞函数中并没有把"this"的引用传递出去，那么其他线程就可以看到final变量的值

## 有序性

对于一个线程的代码而言，在单线程中，代码的执行是从前往后，依次执行的。但是在多线程并发时，程序的执行就有可能出现乱序。用一句话概括为：**在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的**。前半句是指“线程内表现为串行语义”，后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。

**在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象**。只在多线程程序中出现。

