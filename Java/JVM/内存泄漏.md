# 内存泄漏

在Java中，内存泄漏就是存在一些被分配的对象，这些对象有两个特点：**首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象**。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC回收，然后它继续占用内存。

**长生命周期的对象持有短生命周期对象的引用**就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有他的引用而导致不能被回收。

# 造成内存泄漏的几种情况

1. 静态集合类引起内存泄漏

   像HashMap、Vector等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，他们所引用的所有对象Object也不能被释放，因为他们也将一直被Vector等引用着

2. 当集合里面的对象属性被修改后，再调用remove()方法时不起作用

3. 监听器

   在释放对象的时候却没有删除监听器，增加了内存泄漏的机会

4. 各种连接

   比如数据库连接(`dataSource.getConnection()`)，网络连接(socket)和IO连接，除非其显式调用close()方法将其关闭，否则是不会自动被GC回收的

5. 内部类和外部模块的引用

   内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A负责A模块，调用了B模块的一个方法如：`public void registerMsg(Object b)`;这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。

6. 单例模式

   不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在(以静态变量的方式)，如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄露。

下面给出了一个简单的内存泄露的例子。在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个Vector中，如果我们仅仅释放引用本身，那么Vector仍然引用该对象，所以这个对象对GC来说是不可回收的。因此，如果对象加入到Vector后，还必须从Vector中删除，最简单的方法就是将Vector对象设置为null

```
Vector v = new Vector(10);
for (int i = 0; i < 100; i++){
    Object o = new Object();
    v.add(o);
    o = null;
}
```

