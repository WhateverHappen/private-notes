# 一、排序算法的归类

![img](1156494-ab4cecff133d87b3.png)

八大排序算法，关系如上

# 二、各大排序特点

稳定性：

+ 稳定排序：插冒归基(直接插入排序、冒泡排序、归并排序、基数排序)
+ 不稳定：快选堆希(快速排序、选择排序、堆排序、希尔排序)

![img](20160326154410994.png) 

# 三、各种排序详解

## 1.冒泡排序

### 算法简介

冒泡排序是通过对相邻的数据元素进行交换，逐步将待排序序列排成有序序列的过程。

如以升序为例：在一趟排序中，从第一个元素开始，扫描整个**待排序序列**，在一趟扫描中，最终必将最大元素放在整个序列**末尾**。

然后进行第二趟，直至整个序列有序。**每一次排序只会确定一个元素的最终位置**。

下面代码中展示**最基本的**冒泡排序以及**两种优化后的**冒泡排序。

[code](./code/BubbleSort.java)

### 复杂度分析

**最好的情况**就是当整个序列是按照期望有序即正排序的时候，则只需进行一趟排序，进行n-1次比较，无需移动元素，即**外层for循环只执行一次，复杂度为O(n)**。其外层循环执行 N - 1次。内层循环最多的时候执行N次，最少的时候执行1次，平均执行 `(N+1)/2`次。 所以循环体内的比较交换约执行 `(N - 1)(N + 1) / 2 = (N^2 - 1)/2` ，即**平均时间复杂度**为`O(N^2)` 。**最坏情况**下时间复杂度为`O(N^2)`。

## 2.快速排序

### 算法简介

快速排序从待排序记录中选取一个记录（通常选取第一个记录，当然也可采用随即划分的方式，这样能大大提高快速排序的执行效率，如我们所熟知的在O(n)的时间复杂度内找出前k元的算法），将其关键字记为K1，然后将其余关键字小于K1的记录移到前面，而**大于关键字K1的移到后面**，一趟快速排序之后，将待排序序列划分为两个子表，最后将**关键字K1插到这两个子表的分界线的位置**。 

代码如下：

[code](./code/QuickSort.java)

### 复杂度分析

平均时间复杂度为`O(nlogn)`。最坏情况下，将退化为冒泡排序，时间复杂度为`O(n^2)`。

## 3.直接插入排序

### 算法简介

对于给定的一个数组，初始时假设**第一个记录自成一个有序序列，其余记录为无序序列**。接着从第二个记录开始，按照记录的大小，依次将当前处理的记录插入到之前的有序序列中，直至最后一个记录插入到有序序列中为止。

代码如下：

[code](./code/InsertSort.java)

### 复杂度分析

平均时间复杂度为O(n\^2)；最好O(n)，最坏O(n\^2)。

## 4.希尔排序

### 算法简介

希尔排序是把记录按下标的一定增量分组，对**每组使用直接插入排序算法排序**；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

代码如下：

[code](./code/ShellSort.java)

### 复杂度分析

最好和平均时间复杂度都为O(nlogn)，最坏时间复杂度为O(n^2)。

## 5.简单选择排序

### 算法简介

对于给定的一组记录，经过第一轮比较后，得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，最小记录与第二个位置交换，重复该过程，直至整个记录有序。

代码如下：

[code](./code/SelectSort.java)

### 复杂度分析

时间复杂度为O(n^2)。

## 6.堆排序

小根堆：每个结点的关键字都不大于其孩子结点的关键字。 

大根堆：每个结点的关键字都不小于其孩子结点的关键字。 

### 算法简介

堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。

堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。

1. 用大根堆排序的基本思想 

> 先将初始数组建成一个大根堆，此堆为初始的无序区 
 再将最大的元素（即堆顶）和无序区的最后一个记录交换，由此得到新的无序区和有序区，且满足的值<=的值。 
 由于交换后新的根可能违反堆性质，故应将当前无序区调整为堆。然后再次将中最大的元素和该区间的最后一个记录交换，由此得到新的无序区和有序区，且仍满足关系的值<=的值，同样要将调整为堆。

2. 大根堆排序算法的基本操作： 

> 建堆：建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。 
调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。
堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。

### 复杂度分析

平均、最好、最坏时间复杂度都为O(nlogn)

[code](./code/HeapSort.java)

## 7.归并排序

### 算法简介

归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 

归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 

归并操作的工作原理如下： 

1. 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.
 
2. 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作

3. 合并: 合并两个排好序的子序列,生成排序结果.

[code](./code/MergeSort.java)

### 复杂度分析

平均、最好、最坏时间复杂度都为O(nlogn)

## 8.基数排序

### 算法简介

基数排序(radix sort)又称桶排序（bucket sort），相对于常见的比较排序，基数排序是一种分配式排序，即通过将所有数字分配到应在的位置最后再覆盖到原数组完成排序的过程。

**初始化**：构造一个10*n的二维数组，一个长度为n的数组用于存储每次位排序时每个桶子里有多少个元素。
 
**循环操作**：从低位开始（我们采用LSD的方式），将所有元素对应该位的数字存到相应的桶子里去（对应二维数组的那一列）。然后将所有桶子里的元素按照桶子标号从小到大取出，对于同一个桶子里的元素，先放进去的先取出，后放进去的后取出（保证排序稳定性）。这样原数组就按该位排序完毕了，继续下一位操作，直到最高位排序完成。
 
 [code](./code/RadixSort.java)
 
### 复杂度分析

平均时间复杂度为O(d(r+n)),其中，r代表关键字的基数，d代表长度，n代表关键字个数